The Cocke-Younger-Kasami (CYK) algorithm is a dynamic programming algorithm used to determine whether a given string can be generated by a context-free grammar (CFG) in Chomsky Normal Form (CNF). It's widely used in syntax analysis for natural language processing (NLP) and compiler design.

Chomsky Normal Form (CNF):
In CNF, every production rule in a context-free grammar must be one of the following:

A → BC (A nonterminal A is rewritten as a sequence of two nonterminals B and C).

A → a (A nonterminal A is rewritten as a terminal a).

CYK Algorithm Overview:
The CYK algorithm tries to determine whether a string s of length n can be derived from a given CFG in CNF. The key idea is to fill in a table P, where each cell P[i][j] represents the set of nonterminal symbols that can generate the substring s[i:i+j+1] (the substring starting at index i with length j+1).

Steps for the CYK Algorithm:
Initialization: Create a table P of size n x n, where n is the length of the input string. Initially, each cell P[i][j] is a set that will hold the nonterminals for the substring s[i:i+j+1].

Base Case: For each character in the string, find the nonterminals that can generate that character based on the grammar and fill the table.

Inductive Step: For longer substrings, try all possible splits and check which nonterminals can generate the substring by combining two nonterminals.

Result: After filling the table, check if the start symbol (typically the start of the grammar) can generate the entire string.

CYK Algorithm in Python:
Here's a Python implementation of the CYK algorithm for a CFG in CNF.

Example CFG:
Let’s consider a simple grammar in CNF:

S → AB

A → a

B → b

This grammar generates strings of the form "ab".

CYK Algorithm Code:
python
Copiar
def cyk_algorithm(grammar, string):
    # Length of the string
    n = len(string)
    
    # Initialize a table P where P[i][j] will store the set of nonterminals that generate s[i:i+j+1]
    P = [[set() for _ in range(n)] for _ in range(n)]
    
    # Step 1: Fill the table for the substrings of length 1 (single characters)
    for i in range(n):
        for left, right in grammar.get(string[i], []):  # Grammar provides (nonterminal, terminal) pairs
            P[i][0].add(left)  # Add nonterminal that generates this terminal
    
    # Step 2: Fill the table for substrings of length greater than 1
    for length in range(2, n + 1):  # Substring lengths from 2 to n
        for i in range(n - length + 1):  # Starting index of the substring
            for k in range(i, i + length - 1):  # Split the substring
                for left, right in grammar.items():
                    if (right[0] in P[i][k - i]) and (right[1] in P[k + 1][i + length - k - 1]):
                        P[i][length - 1].add(left)  # Add nonterminal for this combination
    
    # Step 3: Check if the start symbol can generate the entire string
    return 'S' in P[0][n - 1]  # Check if start symbol 'S' can generate the entire string

# Example CFG (Context-Free Grammar in Chomsky Normal Form)
grammar = {
    'a': [('A', )],  # A → a
    'b': [('B', )],  # B → b
    'S': [('A', 'B')]  # S → AB
}

# Test the CYK algorithm
string = "ab"
print(cyk_algorithm(grammar, string))  # Should return True because "ab" is generated by the grammar
Explanation of the Code:
Grammar Representation: The grammar is represented as a dictionary where the keys are the terminal symbols, and the values are a list of pairs representing the production rules for the nonterminal. For example, the rule A → a is stored as 'a': [('A',)], meaning "A can produce 'a'".

Table Initialization: We initialize a table P of size n x n where each entry P[i][j] stores a set of nonterminals that can generate the substring s[i:i+j+1]. The table is initialized with empty sets.

Base Case: For each character in the string, the nonterminals that can produce that character are added to the table P[i][0]. This is based on the grammar's terminal rules.

Inductive Step: For substrings of length greater than 1, we try every possible split. If a substring can be formed by concatenating two smaller substrings (from different positions in the string), we add the corresponding nonterminal to the table P.

Result: Finally, we check if the start symbol S can generate the entire string by looking at the entry P[0][n-1].

Example Walkthrough:
Given the string "ab" and the grammar:

css
Copiar
S → AB
A → a
B → b
Base Case:

For the first character 'a': Add A to P[0][0].

For the second character 'b': Add B to P[1][0].

Inductive Step:

For substring "ab" (length 2), check possible splits:

Split at position 1: We check if there's a rule S → AB:

A can generate 'a' (from P[0][0]).

B can generate 'b' (from P[1][0]).

Therefore, add S to P[0][1].

Final Check:

We see that S is in P[0][1], meaning the string "ab" can be generated by the grammar.

Output:
python
Copiar
True
Conclusion:
The CYK algorithm is a powerful method for determining whether a string can be derived from a context-free grammar in Chomsky Normal Form. The provided Python implementation efficiently fills a dynamic programming table to solve this problem. The algorithm has a time complexity of O(n^3) due to the nested loops (where n is the length of the string).
