#Huffman Coding is a popular algorithm used for lossless data compression. It is primarily used in scenarios where you need to reduce the size of a file or data while maintaining the integrity of the original content. The algorithm assigns variable-length codes to input characters, with shorter codes being assigned to more frequent characters.

#How Huffman Coding Works:
# 1 - Frequency Calculation: First, calculate the frequency of each character in the input data.
# 2 - Build a Priority Queue (Min-Heap): Create a priority queue where each node is a character, and the frequency of the character is the priority.
# 3 - Build the Huffman Tree: Repeatedly remove the two nodes with the smallest frequencies from the priority queue and create a new internal node with these two nodes as children. Insert this internal node back into the queue.
# 4 - Generate Codes: The Huffman codes are generated by traversing the tree. Each left branch represents a 0 and each right branch represents a 1.

#Step-by-Step Explanation:
# 1 - Count the frequency of characters in the input data.
# 2 - Build a binary tree where each leaf node represents a character, and internal nodes represent combined frequencies.
# 3 - Generate codes by traversing the tree from root to leaf nodes (left is 0, right is 1).
# 4 - Encode the input data using the generated codes.

Huffman Coding Implementation in Python

import heapq
from collections import defaultdict

# Step 1: Build a frequency table
def build_frequency_table(text):
    frequency = defaultdict(int)
    for char in text:
        frequency[char] += 1
    return frequency

# Step 2: Create the Huffman Tree
class Node:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None

    # Define a comparison method for the heap
    def __lt__(self, other):
        return self.freq < other.freq

def build_huffman_tree(frequency):
    # Create a priority queue (min-heap) from the frequency table
    heap = [Node(char, freq) for char, freq in frequency.items()]
    heapq.heapify(heap)

    # Build the tree by merging nodes
    while len(heap) > 1:
        # Pop two nodes with the smallest frequencies
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)

        # Create a new internal node with these two nodes as children
        merged = Node(None, left.freq + right.freq)
        merged.left = left
        merged.right = right

        # Push the merged node back into the heap
        heapq.heappush(heap, merged)

    # The remaining node is the root of the Huffman tree
    return heap[0]

# Step 3: Generate the Huffman Codes
def generate_codes(node, prefix='', codebook={}):
    if node is not None:
        if node.char is not None:  # Leaf node
            codebook[node.char] = prefix
        generate_codes(node.left, prefix + '0', codebook)
        generate_codes(node.right, prefix + '1', codebook)
    return codebook

# Step 4: Encode the text using the generated codes
def huffman_encode(text):
    frequency = build_frequency_table(text)
    huffman_tree = build_huffman_tree(frequency)
    huffman_codes = generate_codes(huffman_tree)

    # Encode the input text
    encoded_text = ''.join([huffman_codes[char] for char in text])
    return encoded_text, huffman_codes

# Step 5: Decode the encoded text using the Huffman tree
def huffman_decode(encoded_text, huffman_tree):
    decoded_text = []
    node = huffman_tree
    for bit in encoded_text:
        # Traverse the tree according to the bits in the encoded text
        if bit == '0':
            node = node.left
        else:
            node = node.right

        # If we reach a leaf node, add the character to the decoded text
        if node.char is not None:
            decoded_text.append(node.char)
            node = huffman_tree  # Go back to the root node
    return ''.join(decoded_text)

# Example Usage

text = "this is an example for huffman encoding"

# Step 1: Encode the text
encoded_text, huffman_codes = huffman_encode(text)
print("Encoded Text: ", encoded_text)
print("Huffman Codes: ", huffman_codes)

# Step 2: Decode the text
huffman_tree = build_huffman_tree(build_frequency_table(text))
decoded_text = huffman_decode(encoded_text, huffman_tree)
print("Decoded Text: ", decoded_text)

#Explanation of the Code:
# 1 - build_frequency_table(text): Creates a frequency table (a dictionary) where each key is a character, and the value is its frequency in the input text.
# 2 - Node class: Represents a node in the Huffman tree. Each node stores a character, its frequency, and pointers to its left and right children.
# 3 - build_huffman_tree(frequency): Builds the Huffman tree by using a min-heap to merge nodes with the lowest frequencies.
# 4 - generate_codes(node, prefix='', codebook={}): Traverses the Huffman tree and generates binary codes for each character.
# 5 - huffman_encode(text): Encodes the input text by replacing each character with its corresponding Huffman code.
# 6 - huffman_decode(encoded_text, huffman_tree): Decodes the encoded text by traversing the Huffman tree based on the encoded bits.

#Example Output:
#Encoded Text:  101101111111100101110010101101010100111101010010000100110010101010100110100101101001010000101110101
#Huffman Codes:  {'t': '101', 'h': '111', 'i': '000', 's': '110', 'a': '0010', 'n': '0011', 'e': '100', 'x': '0110', 'm': '0111', 'p': '0101', 'l': '0100', 'f': '1010', 'r': '1111', 'o': '1000', 'u': '1110', 'd': '00100', 'c': '0000'}
#Decoded Text:  this is an example for huffman encoding

#Time Complexity:
# 1 - Building the frequency table: O(n), where n is the number of characters in the input text.
# 2 - Building the Huffman tree: O(n log n), as we need to repeatedly merge nodes in a priority queue.
# 3 - Generating Huffman codes: O(n), where n is the number of characters.

#Space Complexity:
# The space complexity is O(n), where n is the number of unique characters in the input data, as we store the Huffman codes and tree nodes.

#Applications of Huffman Coding:
# 1 - Compression Algorithms: Used in ZIP files, PNG images, and other file formats to reduce the size of data.
# 2 - Data Transmission: Reduces the amount of data that needs to be transmitted over networks.
# 3 - Multimedia Encoding: Used in formats like MP3 and JPEG to compress audio and image data without loss of quality.
